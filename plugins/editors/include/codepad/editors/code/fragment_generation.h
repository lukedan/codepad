// Copyright (c) the Codepad contributors. All rights reserved.
// Licensed under the Apache License, Version 2.0. See LICENSE.txt in the project root for license information.

#pragma once

/// \file
/// Structs used to generate text fragments to be rendered in a \ref codepad::editors::code::contents_region.

#include <tuple>

#include "../buffer.h"
#include "interpretation.h"
#include "view.h"

namespace codepad::editors::code {
	class contents_region;


	/// Indicates that no fragment is produced by the current component.
	struct no_fragment {
	};
	/// A fragment of text.
	struct text_fragment {
		/// Default constructor.
		text_fragment() = default;
		/// Initializes all fields of this struct.
		text_fragment(std::basic_string<codepoint> txt, colord c, std::shared_ptr<ui::font> f, bool gizmo) :
			text(txt), color(c), font(std::move(f)), is_gizmo(gizmo) {
		}

		/// Initializes this fragment as a gizmo using a UTF-8 string.
		[[nodiscard]] static text_fragment gizmo_from_utf8(std::u8string_view, colord, std::shared_ptr<ui::font>);

		std::basic_string<codepoint> text; ///< The text.
		colord color; ///< The color of this clip of text.
		std::shared_ptr<ui::font> font; ///< The font used to render this text.
		bool is_gizmo = false; ///< Indicates that this fragment is a gizmo rather than text in the document.
	};
	/// A fragment that contains a single tab character.
	struct tab_fragment {
	};
	/// A fragment that contains a single linebreak.
	struct linebreak_fragment {
		/// Default constructor.
		linebreak_fragment() = default;
		/// Initializes all fields of this struct.
		explicit linebreak_fragment(ui::line_ending le) : type(le) {
		}

		/// The type of this linebreak. For soft linebreaks, this will be \ref ui::line_ending::none.
		ui::line_ending type = ui::line_ending::none;
	};
	/// Indicates that the next fragment to be rendered is an image.
	struct image_gizmo_fragment {
		// TODO
	};

	/// Contains information about a fragment to be rendered.
	using fragment = std::variant<
		no_fragment, text_fragment, tab_fragment, linebreak_fragment, image_gizmo_fragment
	>;
	/// Holds the result of a step of fragment generation.
	struct fragment_generation_result {
		/// Constructs this struct to indicate that no fragment is generated.
		fragment_generation_result() = default;
		/// Initializes all fields of this struct.
		fragment_generation_result(fragment frag, std::size_t diff) : result(std::move(frag)), steps(diff) {
		}
		/// Initializes all fields of this struct.
		template <typename T> constexpr fragment_generation_result(T tok, std::size_t diff) :
			result(std::in_place_type<T>, std::move(tok)), steps(diff) {
		}

		fragment result; ///< The generated fragment.
		/// The number of characters to move forward. If \ref result holds a \ref no_fragment, then this member
		/// indicates how many characters before the next fragment will be generated.
		std::size_t steps = 0;

		/// Returns a \ref fragment_generation_result
		inline static fragment_generation_result exhausted() {
			return fragment_generation_result(no_fragment(), std::numeric_limits<std::size_t>::max());
		}
	};


	/// Used to format a \ref codepoint for display.
	using invalid_codepoint_fragment_func = std::function<fragment(codepoint)>;


	/// Used to host additional components of the \ref fragment_generator. Each component must contain the following
	/// three functions: \p generate(), which optionally generates a fragment for the current position;
	/// \p reposition(), which is used to notify this component of the change of the current position; and
	/// \p update(), which is also used to notify of the change of the position, but the position is guaranteed to
	/// move forward and the change is likely small, which may allow for some optimizations.
	template <typename ...Args> struct fragment_generator_component_hub {
	public:
		/// Initializes \ref _components directly.
		template <typename ...InitArgs> explicit fragment_generator_component_hub(InitArgs &&...args) :
			_components(std::forward<InitArgs>(args)...) {
		}

		/// Generates a fragment. If no fragment is generated (i.e., \ref fragment_generation_result::result holds a
		/// \ref no_fragment), \ref fragment_generation_result::steps holds the minimum number of steps before a
		/// fragment would be generated by a component.
		fragment_generation_result generate(std::size_t position) {
			return _generate_impl(position);
		}
		/// Updates all components.
		void update(std::size_t oldpos, std::size_t steps) {
			_update_impl(oldpos, steps, std::make_index_sequence<sizeof...(Args)>());
		}
		/// Repositions all components.
		void reposition(std::size_t position) {
			_reposition_impl(position, std::make_index_sequence<sizeof...(Args)>());
		}
	protected:
		std::tuple<Args...> _components; ///< The components.

		/// Recursive implementation of \ref generate().
		template <std::size_t Index = 0> fragment_generation_result _generate_impl(
			[[maybe_unused]] std::size_t position
		) {
			if constexpr (Index < sizeof...(Args)) {
				fragment_generation_result frag =
					std::get<std::min(Index, sizeof...(Args) - 1)>(_components).generate(position);
				if (std::holds_alternative<no_fragment>(frag.result)) { // nope
					std::size_t steps = frag.steps;
					frag = _generate_impl<Index + 1>(position);
					if (std::holds_alternative<no_fragment>(frag.result)) { // still nope
						frag.steps = std::min(frag.steps, steps);
					}
				}
				return frag;
			} else {
				return fragment_generation_result::exhausted();
			}
		}
		/// Implementation of \ref update().
		template <std::size_t ...Indices> void _update_impl(
			std::size_t oldpos, std::size_t steps, std::index_sequence<Indices...>
		) {
			(..., std::get<Indices>(_components).update(oldpos, steps));
		}
		/// Implementation of \ref reposition().
		template <std::size_t ...Indices> void _reposition_impl(
			std::size_t position, std::index_sequence<Indices...>
		) {
			(..., std::get<Indices>(_components).reposition(position));
		}
	};

	/// Iterates through a range of text in a \ref interpretation and generates fragments to be rendered.
	template <typename Hub> struct fragment_generator {
		/// The maximum length of a single text fragment.
		constexpr static std::size_t maximum_text_fragment_length = 100;

		/// Constructs this \ref fragment_generator with the given \ref interpretation and starting position, and the
		/// \ref fragment_generator_component_hub from all other arguments. The \ref invalid_codepoint_fragment_func
		/// is only referenced and must outlive this generator object.
		template <typename ...Args> fragment_generator(
			const interpretation &interp, const invalid_codepoint_fragment_func &invcp_func,
			const std::vector<std::shared_ptr<ui::font_family>> &fonts,
			std::size_t begpos,
			Args &&...args
		) :
			_components(std::forward<Args>(args)...), _inv_cp_frag_func(invcp_func),
			_pos(begpos), _interp(interp), _font_set(fonts) {

			reposition(_pos);
		}

		/// Returns the fragment for the character or linebreak, and advances to the next character.
		fragment_generation_result generate_and_update() {
			// generate (also _char_it is updated in this step)
			fragment_generation_result res = _components.generate(get_position());
			if (std::holds_alternative<no_fragment>(res.result)) { // generate text
				if (!_char_it.codepoint().is_codepoint_valid()) { // invalid codepoint
					res = fragment_generation_result(_inv_cp_frag_func(_char_it.codepoint().get_codepoint()), 1);
					_char_it.next();
				} else if (_char_it.is_linebreak()) { // hard linebreak
					res = fragment_generation_result(linebreak_fragment(_char_it.get_linebreak()), 1);
					_char_it.next();
				} else if (_char_it.codepoint().get_codepoint() == '\t') { // tab
					res = fragment_generation_result(tab_fragment(), 1);
					_char_it.next();
				} else { // otherwise generate a clip of text
					std::size_t maxsteps = std::min(res.steps, maximum_text_fragment_length);
					maxsteps = std::min(maxsteps, _theme_it.forecast(_pos)); // integrate theme information
					res.steps = 0;
					text_fragment &frag = res.result.emplace<text_fragment>();
					frag.color = _theme_it.current_theme.color;
					std::size_t fontid = _select_font(_char_it.codepoint().get_codepoint());
					frag.font = _cached_fonts[fontid];
					do {
						frag.text.push_back(_char_it.codepoint().get_codepoint());
						_char_it.next();
						++res.steps;
					} while (
						res.steps < maxsteps && !_char_it.codepoint().ended() &&
						// invalid codepoints, linebreaks, and tabs are handled elsewhere
						_char_it.codepoint().is_codepoint_valid() &&
						!_char_it.is_linebreak() && _char_it.codepoint().get_codepoint() != '\t' &&
						// make sure the whole clip uses the same font
						_select_font(_char_it.codepoint().get_codepoint()) == fontid
					);
				}
			} else { // only update _char_it
				if (res.steps == 1) {
					_char_it.next();
				} else if (res.steps > 1) {
					_char_it = _interp.character_at(_pos + res.steps); // TODO room for optimization
				}
			}
			// update everything else
			std::size_t oldpos = _pos;
			_pos += res.steps;
			text_theme_member changed = _theme_it.move_forward(_pos);
			if ((changed & (text_theme_member::style | text_theme_member::weight)) != text_theme_member::none) {
				_cached_fonts.clear();
			}
			_components.update(oldpos, res.steps);
			return res;
		}
		/// Resets the current position.
		void reposition(std::size_t pos) {
			_cached_fonts.clear(); // clear cached fonts
			_pos = pos;
			_char_it = _interp.character_at(_pos);
			_theme_it = text_theme_data::position_iterator(_interp.get_text_theme(), _pos);
			_components.reposition(_pos);
		}

		/// Returns the current postiion of this iterator. If this called inside the \p update() method of a
		/// component, then the returned position is that before updating.
		std::size_t get_position() const {
			return _pos;
		}
	protected:
		Hub _components; ///< Extra components.

		/// The list of fonts cached for the current font paremeters specified by \ref _theme_it.
		std::vector<std::shared_ptr<ui::font>> _cached_fonts;

		/// Iterator to the current character in the \ref interpretation.
		interpretation::character_iterator _char_it;
		/// Iterator to the current entry in the \ref text_theme_data that determines the theme of the text.
		text_theme_data::position_iterator _theme_it;

		/// Function used to generate fragments for invalid codepoints.
		const invalid_codepoint_fragment_func &_inv_cp_frag_func;

		std::size_t _pos = 0; ///< The position of character \ref _char_it points to.
		const interpretation &_interp; ///< The associated \ref interpretation.
		/// The list of fonts. Fonts in the back are backups for those in the front.
		const std::vector<std::shared_ptr<ui::font_family>> &_font_set;


		/// Selects a font for the given codepoint.
		std::size_t _select_font(codepoint cp) {
			for (std::size_t i = 0; i < _font_set.size(); ++i) {
				if (_cached_fonts.size() <= i) { // the font has not been cached yet
					// TODO custom font stretch
					_cached_fonts.emplace_back(_font_set[i]->get_matching_font(
						_theme_it.current_theme.style, _theme_it.current_theme.weight, ui::font_stretch::normal
					));
				}
				if (_cached_fonts[i]->has_character(cp)) {
					return i;
				}
			}
			return 0; // if none of the fonts have the characer, use replacement glyph from the first font
		}
	};


	/// A component that inserts soft linebreaks into the document.
	struct soft_linebreak_inserter {
	public:
		/// Initializes this struct with the given \ref soft_linebreak_registry at the given position.
		soft_linebreak_inserter(const soft_linebreak_registry &reg, std::size_t pos) : _reg(reg) {
			reposition(pos);
		}

		/// Checks and generates a soft linebreak if necessary. \ref _cur_softbreak and \ref _prev_chars are updated
		/// here instead of in \ref update() because this component don't really advance the current position and
		/// will otherwise cause conflicts.
		fragment_generation_result generate(std::size_t);
		/// Updates \ref _cur_softbreak according to the given offset.
		void update(std::size_t oldpos, std::size_t steps);
		/// Resets the current position.
		void reposition(std::size_t position) {
			auto softbreak = _reg.get_softbreak_before_or_at_char(position);
			_prev_chars = softbreak.prev_chars;
			_cur_softbreak = softbreak.entry;
		}
	protected:
		soft_linebreak_registry::iterator _cur_softbreak; ///< Iterator to the next soft linebreak.
		const soft_linebreak_registry &_reg; ///< The registry for soft linebreaks.
		std::size_t _prev_chars = 0; ///< The number of characters before \ref _cur_softbreak.
	};
	/// A component that jumps to the ends of folded regions and generates corresponding gizmos.
	struct folded_region_skipper {
	public:
		/// Function type used to generate a fragment corresponding to the given folded region.
		using fragment_func = std::function<fragment(const folding_registry::iterator&)>;

		/// Initializes this struct with the given \ref folding_registry at the given position. The input
		/// \ref fragment_func is not copied and the referenced function object must outlive this component.
		folded_region_skipper(const folding_registry &reg, const fragment_func &frag_func, std::size_t pos) :
			_frag_func(frag_func), _reg(reg) {

			reposition(pos);
		}

		/// Checks and skips the folded region if necessary.
		fragment_generation_result generate(std::size_t);
		/// Updates \ref _cur_region according to the given offset.
		void update(std::size_t oldpos, std::size_t steps);
		/// Resets the current position.
		void reposition(std::size_t position) {
			auto region = _reg.find_region_containing_or_first_after_open(position);
			_cur_region = region.entry;
			if (_cur_region != _reg.end()) {
				_region_start = region.prev_chars + _cur_region->gap;
			}
		}
	protected:
		const fragment_func &_frag_func; ///< The fragment generation function.
		folding_registry::iterator _cur_region; ///< Iterator to the next folded region.
		const folding_registry &_reg; ///< The registry for folded regions.
		std::size_t _region_start = 0; ///< Position of the beginning of the next folded region.
	};


	/// Used to format, measure, and assemble \ref fragment "fragments".
	class fragment_assembler {
	public:
		/// Used when the fragment should be rendered as text.
		struct text_rendering {
			/// Default constructor.
			text_rendering() = default;
			/// Initializes all fields of this struct.
			text_rendering(std::shared_ptr<ui::plain_text> t, vec2d pos, double basecorr, colord c) :
				text(std::move(t)), topleft(pos), baseline_correction(basecorr), color(c) {
			}

			std::shared_ptr<ui::plain_text> text; ///< The formatted text.
			vec2d topleft; ///< The top-left position of this fragment, without \ref baseline_correction.
			/// The offset to add to the result of \ref get_vertical_position() to align the baseline of all text.
			double baseline_correction = 0.0;
			colord color; ///< The color of the text.

			/// Returns the width of \ref text.
			[[nodiscard]] double get_width() const {
				return text->get_width();
			}
		};
		/// Basic information about unrendered fragments.
		struct basic_rendering {
			/// Default constructor.
			basic_rendering() = default;
			/// Initializes all fields of this struct.
			basic_rendering(vec2d v, double w) : topleft(v), width(w) {
			}

			vec2d topleft; ///< The top-left position of this fragment.
			double width = 0.0; ///< The width of this fragment.

			/// Returns \ref width.
			[[nodiscard]] double get_width() const {
				return width;
			}
		};
		/// Storage for a single rendering object generated from a fragment.
		using rendering_storage = std::variant<text_rendering, basic_rendering>;

		/// Initializes the renderer, font, and spacing.
		fragment_assembler(
			ui::renderer_base &r, const ui::font_family &ff, double sz, double lh, double base, double tabw
		) : _renderer(&r), _font_family(ff), _font_size(sz), _line_height(lh), _baseline(base), _tab_width(tabw) {
		}
		/// Initializes this struct using the given \ref contents_region.
		fragment_assembler(const contents_region&);

		/// Returns the line height set for this \ref fragment_assembler.
		[[nodiscard]] double get_line_height() const {
			return _line_height;
		}
		/// Returns the position of the baseline relative to the top of the line.
		[[nodiscard]] double get_baseline() const {
			return _baseline;
		}

		/// Sets \ref _xpos.
		void set_horizontal_position(double pos) {
			_xpos = pos;
		}
		/// Adds the given value to \ref _xpos.
		void advance_horizontal_position(double diff) {
			set_horizontal_position(get_horizontal_position() + diff);
		}
		/// Returns the starting horizontal position for the next fragment.
		[[nodiscard]] double get_horizontal_position() const {
			return _xpos;
		}
		/// Sets \ref _line_top.
		void set_vertical_position(double pos) {
			_line_top = pos;
		}
		/// Increases the vertical position by the given number times the line height.
		void advance_vertical_position(std::size_t lines) {
			set_vertical_position(get_vertical_position() + static_cast<double>(lines) * get_line_height());
		}
		/// Returns the top position of the current line.
		[[nodiscard]] double get_vertical_position() const {
			return _line_top;
		}
		/// Returns the combined result of \ref get_horizontal_position() and \ref get_vertical_position().
		vec2d get_position() const {
			return vec2d(get_horizontal_position(), get_vertical_position());
		}

		/// Does nothing but returning the current position. Normally this wouldn't be called.
		basic_rendering append(const no_fragment&) {
			return basic_rendering(get_position(), 0.0);
		}
		/// Appends a \ref text_fragment to the rendered document by calling \ref _append_text().
		text_rendering append(const text_fragment &frag) {
			return _append_plain_text(
				_renderer->create_plain_text(frag.text, *frag.font, _font_size),
				*frag.font, _font_size, frag.color
			);
		}
		/// Appends a \ref tab_fragment to the rendered document.
		basic_rendering append(const tab_fragment&) {
			double next_pos = (std::floor(get_horizontal_position() / _tab_width) + 1.0) * _tab_width;
			basic_rendering r(get_position(), next_pos - get_horizontal_position());
			set_horizontal_position(next_pos);
			return r;
		}
		/// Appends a \ref linebreak_fragment to the rendered document by simply moving the current position.
		basic_rendering append(const linebreak_fragment &linebreak) {
			// TODO use the width of a space?
			basic_rendering r(get_position(), linebreak.type == ui::line_ending::none ? 0.0 : 10.0);
			set_horizontal_position(0.0);
			advance_vertical_position(1);
			return r;
		}
		/// Appends a \ref image_gizmo_fragment to the rendered document.
		basic_rendering append(const image_gizmo_fragment&) {
			// TODO
			return basic_rendering(get_position(), 0.0);
		}

		/// Appends a \ref text_fragment to the document, taking the fast path for laying out text.
		text_rendering append_fast(const text_fragment &frag) {
			return _append_plain_text(
				_renderer->create_plain_text_fast(frag.text, *frag.font, _font_size),
				*frag.font, _font_size, frag.color
			);
		}

		/// Does nothing. Defined to complete the basic interface.
		inline static void render(ui::renderer_base&, const basic_rendering&) {
		}
		/// Renders the text using the given renderer, at the position specified in the \ref text_rendering.
		/// Additional transformations may be necessary to 
		inline static void render(ui::renderer_base &r, const text_rendering &text) {
			r.draw_plain_text(
				*text.text, vec2d(text.topleft.x, text.topleft.y + text.baseline_correction), text.color
			);
		}
	protected:
		ui::renderer_base *_renderer = nullptr; ///< The renderer.
		const ui::font_family &_font_family; ///< The font family.
		double
			_font_size = 0.0, ///< The font size.
			_line_height = 0.0, ///< The height of a line.
			_baseline = 0.0, ///< The desired base line position from the top of the line.
			_tab_width = 0.0, ///< The maximum width of a tab character.
			_line_top = 0.0, ///< The top of the current line.
			_xpos = 0.0; ///< The horizontal position, relative to the left side of the document.

		/// Appends a clip of text to the ending of the document.
		text_rendering _append_plain_text(
			std::shared_ptr<ui::plain_text> text, ui::font &font, double size, colord color
		) {
			vec2d pos = get_position();
			advance_horizontal_position(text->get_width());
			return text_rendering(std::move(text), pos, _baseline - font.get_ascent_em() * size, color);
		}
	};
}
