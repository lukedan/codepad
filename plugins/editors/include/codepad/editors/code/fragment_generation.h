// Copyright (c) the Codepad contributors. All rights reserved.
// Licensed under the Apache License, Version 2.0. See LICENSE.txt in the project root for license information.

#pragma once

/// \file
/// Structs used to generate text fragments to be rendered in a \ref codepad::editors::code::contents_region.

#include <tuple>

#include "../buffer.h"
#include "interpretation.h"
#include "view.h"
#include "contents_region.h"

namespace codepad::editors::code {
	/// Indicates that no fragment is produced by the current component.
	struct no_fragment {
	};
	/// A fragment of text that does not contain invalid codepoints, tabs, or linebreaks.
	struct text_fragment {
		/// Default constructor.
		text_fragment() = default;
		/// Initializes all fields of this struct.
		text_fragment(std::basic_string<codepoint> txt, colord c, std::shared_ptr<ui::font> f) :
			text(txt), color(c), font(std::move(f)) {
		}

		std::basic_string<codepoint> text; ///< The text.
		colord color; ///< The color of this clip of text.
		std::shared_ptr<ui::font> font; ///< The font used to render this text.
	};
	/// A fragment that contains a single tab character.
	struct tab_fragment {
	};
	/// A fragment that contains an invalid codepoint.
	struct invalid_codepoint_fragment {
		/// Default constructor.
		invalid_codepoint_fragment() = default;
		/// Initializes \ref value.
		explicit invalid_codepoint_fragment(codepoint cp) : value(cp) {
		}

		codepoint value = 0; ///< The byte value of this codepoint.
	};
	/// A fragment that contains a single linebreak.
	struct linebreak_fragment {
		/// Default constructor.
		linebreak_fragment() = default;
		/// Initializes all fields of this struct.
		explicit linebreak_fragment(ui::line_ending le) : type(le) {
		}

		ui::line_ending type = ui::line_ending::none; ///< The type of this linebreak.
	};

	/// Indicates that the next fragment to be rendered is an image.
	struct image_gizmo_fragment {
		// TODO
	};
	/// Indicates that the next fragment to be rendered is a short clip of text.
	struct text_gizmo_fragment {
		/// Default constructor.
		text_gizmo_fragment() = default;
		/// Initializes all fields of this struct.
		text_gizmo_fragment(ui::font_parameters f, std::u8string str, colord c) : font(f), contents(std::move(str)), color(c) {
		}

		ui::font_parameters font; ///< The font used to render this fragment.
		std::u8string contents; ///< The contents of this fragment.
		colord color; ///< Color used to render this fragment.
	};

	/// Contains information about a fragment to be rendered.
	using fragment = std::variant<
		no_fragment,
		text_fragment, tab_fragment, invalid_codepoint_fragment, linebreak_fragment,
		image_gizmo_fragment, text_gizmo_fragment
	>;
	/// Holds the result of a step of fragment generation.
	struct fragment_generation_result {
		/// Constructs this struct to indicate that no fragment is generated.
		fragment_generation_result() = default;
		/// Initializes all fields of this struct.
		template <typename T> constexpr fragment_generation_result(T tok, std::size_t diff) :
			result(std::in_place_type<T>, tok), steps(diff) {
		}

		fragment result; ///< The generated fragment.
		/// The number of characters to move forward. If \ref result holds a \ref no_fragment, then this member
		/// indicates how many characters before the next fragment will be generated.
		std::size_t steps = 0;

		/// Returns a \ref fragment_generation_result
		inline static fragment_generation_result exhausted() {
			return fragment_generation_result(no_fragment(), std::numeric_limits<std::size_t>::max());
		}
	};


	/// Used to host additional components of the \ref fragment_generator. Each component must contain the following
	/// three functions: \p generate(), which optionally generates a fragment for the current position;
	/// \p reposition(), which is used to notify this component of the change of the current position; and
	/// \p update(), which is also used to notify of the change of the position, but the position is guaranteed to
	/// move forward and the change is likely small, which may allow for some optimizations.
	template <typename ...Args> struct fragment_generator_component_hub {
	public:
		/// Initializes \ref _components directly.
		template <typename ...InitArgs> explicit fragment_generator_component_hub(InitArgs &&...args) :
			_components(std::forward<InitArgs>(args)...) {
		}

		/// Generates a fragment. If no fragment is generated (i.e., \ref fragment_generation_result::result holds a
		/// \ref no_fragment), \ref fragment_generation_result::steps holds the minimum number of steps before a
		/// fragment would be generated by a component.
		fragment_generation_result generate(std::size_t position) {
			return _generate_impl(position);
		}
		/// Updates all components.
		void update(std::size_t oldpos, std::size_t steps) {
			_update_impl(oldpos, steps, std::make_index_sequence<sizeof...(Args)>());
		}
		/// Repositions all components.
		void reposition(std::size_t position) {
			_reposition_impl(position, std::make_index_sequence<sizeof...(Args)>());
		}
	protected:
		std::tuple<Args...> _components; ///< The components.

		/// Recursive implementation of \ref generate().
		template <std::size_t Index = 0> fragment_generation_result _generate_impl(
			[[maybe_unused]] std::size_t position
		) {
			if constexpr (Index < sizeof...(Args)) {
				fragment_generation_result frag =
					std::get<std::min(Index, sizeof...(Args) - 1)>(_components).generate(position);
				if (std::holds_alternative<no_fragment>(frag.result)) { // nope
					std::size_t steps = frag.steps;
					frag = _generate_impl<Index + 1>(position);
					if (std::holds_alternative<no_fragment>(frag.result)) { // still nope
						frag.steps = std::min(frag.steps, steps);
					}
				}
				return frag;
			} else {
				return fragment_generation_result::exhausted();
			}
		}
		/// Implementation of \ref update().
		template <std::size_t ...Indices> void _update_impl(
			std::size_t oldpos, std::size_t steps, std::index_sequence<Indices...>
		) {
			(..., std::get<Indices>(_components).update(oldpos, steps));
		}
		/// Implementation of \ref reposition().
		template <std::size_t ...Indices> void _reposition_impl(
			std::size_t position, std::index_sequence<Indices...>
		) {
			(..., std::get<Indices>(_components).reposition(position));
		}
	};

	/// Iterates through a range of text in a \ref interpretation and generates fragments to be rendered.
	template <typename Hub> struct fragment_generator {
		/// The maximum length of a single text fragment.
		constexpr static std::size_t maximum_text_fragment_length = 100;

		/// Constructs this \ref fragment_generator with the given \ref interpretation and starting position, and the
		/// \ref fragment_generator_component_hub from all other arguments.
		template <typename ...Args> fragment_generator(
			const interpretation &interp,
			const std::vector<std::unique_ptr<ui::font_family>> &fonts,
			std::size_t begpos,
			Args &&...args
		) : _components(std::forward<Args>(args)...), _pos(begpos), _interp(interp), _font_set(fonts) {
			reposition(_pos);
		}

		/// Returns the fragment for the character or linebreak, and advances to the next character.
		fragment_generation_result generate_and_update() {
			// generate (also _char_it is updated in this step)
			fragment_generation_result res = _components.generate(get_position());
			if (std::holds_alternative<no_fragment>(res.result)) { // generate text
				if (!_char_it.codepoint().is_codepoint_valid()) { // invalid codepoint
					res = fragment_generation_result(
						invalid_codepoint_fragment(_char_it.codepoint().get_codepoint()), 1
					);
					_char_it.next();
				} else if (_char_it.is_linebreak()) { // hard linebreak
					res = fragment_generation_result(linebreak_fragment(_char_it.get_linebreak()), 1);
					_char_it.next();
				} else if (_char_it.codepoint().get_codepoint() == '\t') { // tab
					res = fragment_generation_result(tab_fragment(), 1);
					_char_it.next();
				} else { // otherwise generate a clip of text
					std::size_t maxsteps = std::min(res.steps, maximum_text_fragment_length);
					maxsteps = std::min(maxsteps, _theme_it.forecast(_pos)); // integrate theme information
					res.steps = 0;
					text_fragment &frag = res.result.emplace<text_fragment>();
					frag.color = _theme_it.current_theme.color;
					std::size_t fontid = _select_font(_char_it.codepoint().get_codepoint());
					frag.font = _cached_fonts[fontid];
					do {
						frag.text.push_back(_char_it.codepoint().get_codepoint());
						_char_it.next();
						++res.steps;
					} while (
						res.steps < maxsteps && !_char_it.codepoint().ended() &&
						// invalid codepoints, linebreaks, and tabs are handled elsewhere
						_char_it.codepoint().is_codepoint_valid() &&
						!_char_it.is_linebreak() && _char_it.codepoint().get_codepoint() != '\t' &&
						// make sure the whole clip uses the same font
						_select_font(_char_it.codepoint().get_codepoint()) == fontid
						);
				}
			} else { // only update _char_it
				if (res.steps == 1) {
					_char_it.next();
				} else if (res.steps > 1) {
					_char_it = _interp.at_character(_pos + res.steps); // TODO room for optimization
				}
			}
			// update everything else
			std::size_t oldpos = _pos;
			_pos += res.steps;
			text_theme_member changed = _theme_it.move_forward(_pos);
			if ((changed & (text_theme_member::style | text_theme_member::weight)) != text_theme_member::none) {
				_cached_fonts.clear();
			}
			_components.update(oldpos, res.steps);
			return res;
		}
		/// Resets the current position.
		void reposition(std::size_t pos) {
			_cached_fonts.clear(); // clear cached fonts
			_pos = pos;
			_char_it = _interp.at_character(_pos);
			_theme_it = text_theme_data::position_iterator(_interp.get_text_theme(), _pos);
			_components.reposition(_pos);
		}

		/// Returns the current postiion of this iterator. If this called inside the \p update() method of a
		/// component, then the returned position is that before updating.
		std::size_t get_position() const {
			return _pos;
		}
	protected:
		Hub _components; ///< Extra components.

		/// The list of fonts cached for the current font paremeters specified by \ref _theme_it.
		std::vector<std::shared_ptr<ui::font>> _cached_fonts;

		/// Iterator to the current character in the \ref interpretation.
		interpretation::character_iterator _char_it;
		/// Iterator to the current entry in the \ref text_theme_data that determines the theme of the text.
		text_theme_data::position_iterator _theme_it;

		std::size_t _pos = 0; ///< The position of character \ref _char_it points to.
		const interpretation &_interp; ///< The associated \ref interpretation.
		/// The list of fonts. Fonts in the back are backups for those in the front.
		const std::vector<std::unique_ptr<ui::font_family>> &_font_set;


		/// Selects a font for the given codepoint.
		std::size_t _select_font(codepoint cp) {
			for (std::size_t i = 0; i < _font_set.size(); ++i) {
				if (_cached_fonts.size() <= i) { // the font has not been cached yet
					// TODO custom font stretch
					_cached_fonts.emplace_back(_font_set[i]->get_matching_font(
						_theme_it.current_theme.style, _theme_it.current_theme.weight, ui::font_stretch::normal
					));
				}
				if (_cached_fonts[i]->has_character(cp)) {
					return i;
				}
			}
			return 0; // if none of the fonts have the characer, use replacement glyph from the first font
		}
	};


	/// A component that inserts soft linebreaks into the document.
	struct soft_linebreak_inserter {
	public:
		/// Initializes this struct with the given \ref soft_linebreak_registry at the given position.
		soft_linebreak_inserter(const soft_linebreak_registry &reg, std::size_t pos) : _reg(reg) {
			reposition(pos);
		}

		/// Checks and generates a soft linebreak if necessary. \ref _cur_softbreak and \ref _prev_chars are updated
		/// here instead of in \ref update() because this component don't really advance the current position and
		/// will otherwise cause conflicts.
		fragment_generation_result generate(std::size_t position) {
			if (_cur_softbreak != _reg.end()) {
				std::size_t nextpos = _prev_chars + _cur_softbreak->length;
				if (position == nextpos) {
					_prev_chars += _cur_softbreak->length;
					++_cur_softbreak;
					return fragment_generation_result(linebreak_fragment(ui::line_ending::none), 0);
				}
				return fragment_generation_result(no_fragment(), nextpos - position);
			}
			return fragment_generation_result::exhausted();
		}
		/// Updates \ref _cur_softbreak according to the given offset.
		void update(std::size_t oldpos, std::size_t steps) {
			std::size_t newpos = oldpos + steps;
			if (steps > 0 && _cur_softbreak != _reg.end()) { // no update needed if not moved
				if (newpos > _prev_chars + _cur_softbreak->length) {
					// reset once the iterator to the next soft linebreak is invalid
					reposition(newpos);
				}
			}
		}
		/// Resets the current position.
		void reposition(std::size_t position) {
			auto softbreak = _reg.get_softbreak_before_or_at_char(position);
			_prev_chars = softbreak.prev_chars;
			_cur_softbreak = softbreak.entry;
		}
	protected:
		soft_linebreak_registry::iterator _cur_softbreak; ///< Iterator to the next soft linebreak.
		const soft_linebreak_registry &_reg; ///< The registry for soft linebreaks.
		std::size_t _prev_chars = 0; ///< The number of characters before \ref _cur_softbreak.
	};
	/// A component that jumps to the ends of folded regions and generates corresponding gizmos.
	struct folded_region_skipper {
	public:
		/// Initializes this struct with the given \ref folding_registry at the given position.
		folded_region_skipper(const folding_registry &reg, std::size_t pos) : _reg(reg) {
			reposition(pos);
		}

		/// Checks and skips the folded region if necessary.
		fragment_generation_result generate(std::size_t position) {
			if (_cur_region != _reg.end()) {
				if (position >= _region_start) { // jump
					// TODO fragment should be customizable
					return fragment_generation_result(
						text_gizmo_fragment(ui::font_parameters(), u8"...", colord(0.8, 0.8, 0.8, 1.0)),
						_cur_region->range - (position - _region_start)
					);
				}
				return fragment_generation_result(no_fragment(), _region_start - position);
			}
			return fragment_generation_result::exhausted();
		}
		/// Updates \ref _cur_region according to the given offset.
		void update(std::size_t oldpos, std::size_t steps) {
			if (_cur_region != _reg.end()) {
				std::size_t newpos = oldpos + steps, regionend = _region_start + _cur_region->range;
				if (newpos >= regionend) { // advance to the next region and check again
					++_cur_region;
					if (_cur_region != _reg.end()) {
						_region_start = regionend + _cur_region->gap;
						if (_region_start + _cur_region->range <= newpos) { // nope, still ahead
							reposition(newpos);
						}
					}
				}
			}
		}
		/// Resets the current position.
		void reposition(std::size_t position) {
			auto region = _reg.find_region_containing_or_first_after_open(position);
			_cur_region = region.entry;
			if (_cur_region != _reg.end()) {
				_region_start = region.prev_chars + _cur_region->gap;
			}
		}
	protected:
		folding_registry::iterator _cur_region; ///< Iterator to the next folded region.
		const folding_registry &_reg; ///< The registry for folded regions.
		std::size_t _region_start = 0; ///< Position of the beginning of the next folded region.
	};


	/// Used to format, measure, and assemble \ref fragment "fragments".
	class fragment_assembler {
	public:
		/// Used when the fragment should be rendered as text.
		struct text_rendering {
			/// Default constructor.
			text_rendering() = default;
			/// Initializes all fields of this struct.
			text_rendering(std::unique_ptr<ui::plain_text> t, vec2d pos, double basecorr, colord c) :
				text(std::move(t)), topleft(pos), baseline_correction(basecorr), color(c) {
			}

			std::unique_ptr<ui::plain_text> text; ///< The formatted text.
			vec2d topleft; ///< The top-left position of this fragment, without \ref baseline_correction.
			/// The offset to add to the result of \ref get_vertical_position() to align the baseline of all text.
			double baseline_correction = 0.0;
			colord color; ///< The color of the text.
		};
		/// Basic information about unrendered fragments.
		struct basic_rendering {
			/// Default constructor.
			basic_rendering() = default;
			/// Initializes \ref topleft.
			explicit basic_rendering(vec2d v) : topleft(v) {
			}

			vec2d topleft; ///< The top-left position of this fragment.
		};

		/// Initializes the renderer, font, and spacing.
		fragment_assembler(
			ui::renderer_base &r, const ui::font_family &ff, double sz, double lh, double base, double tabw,
			invalid_codepoint_formatter fmt, colord invclr
		) :
			_renderer(&r), _font_family(ff), _invalid_cp_fmt(std::move(fmt)), _invalid_cp_color(invclr),
			_font_size(sz), _line_height(lh), _baseline(base), _tab_width(tabw) {
		}
		/// Initializes this struct using the given \ref contents_region.
		fragment_assembler(const contents_region &rgn) : fragment_assembler(
			rgn.get_manager().get_renderer(), *rgn.get_font_families()[0], rgn.get_font_size(),
			rgn.get_line_height(), rgn.get_baseline(), rgn.get_tab_width(),
			rgn.get_invalid_codepoint_formatter(), rgn.get_invalid_codepoint_color() // TODO custom color
		) {
		}

		/// Returns the line height set for this \ref fragment_assembler.
		double get_line_height() const {
			return _line_height;
		}

		/// Sets \ref _xpos.
		void set_horizontal_position(double pos) {
			_xpos = pos;
		}
		/// Adds the given value to \ref _xpos.
		void advance_horizontal_position(double diff) {
			set_horizontal_position(get_horizontal_position() + diff);
		}
		/// Returns the starting horizontal position for the next fragment.
		double get_horizontal_position() const {
			return _xpos;
		}
		/// Sets \ref _line_top.
		void set_vertical_position(double pos) {
			_line_top = pos;
		}
		/// Increases the vertical position by the given number times the line height.
		void advance_vertical_position(std::size_t lines) {
			set_vertical_position(get_vertical_position() + static_cast<double>(lines) * get_line_height());
		}
		/// Returns the top position of the current line.
		double get_vertical_position() const {
			return _line_top;
		}
		/// Returns the combined result of \ref get_horizontal_position() and \ref get_vertical_position().
		vec2d get_position() const {
			return vec2d(get_horizontal_position(), get_vertical_position());
		}

		/// Does nothing but returning the current position. Normally this wouldn't be called.
		basic_rendering append(const no_fragment&) {
			return basic_rendering(get_position());
		}
		/// Appends a \ref text_fragment to the rendered document by calling \ref _append_text().
		text_rendering append(const text_fragment &frag) {
			return _append_text(std::basic_string_view<codepoint>(frag.text), *frag.font, _font_size, frag.color);
		}
		/// Appends a \ref tab_fragment to the rendered document.
		basic_rendering append(const tab_fragment&) {
			basic_rendering r(get_position());
			set_horizontal_position((std::floor(get_horizontal_position() / _tab_width) + 1.0) * _tab_width);
			return r;
		}
		/// Appends a \ref invalid_codepoint_fragment to the rendered document.
		text_rendering append(const invalid_codepoint_fragment &frag) {
			std::u8string textrepr = _invalid_cp_fmt(frag.value);
			// TODO custom style
			auto font = _font_family.get_matching_font(
				ui::font_style::italic, ui::font_weight::normal, ui::font_stretch::normal
			);
			return _append_text(std::u8string_view(textrepr), *font, _font_size, _invalid_cp_color);
		}
		/// Appends a \ref linebreak_fragment to the rendered document by simply moving the current position.
		basic_rendering append(const linebreak_fragment&) {
			basic_rendering r(get_position());
			set_horizontal_position(0.0);
			advance_vertical_position(1);
			return r;
		}
		/// Appends a \ref image_gizmo_fragment to the rendered document.
		basic_rendering append(const image_gizmo_fragment&) {
			// TODO
			return basic_rendering(get_position());
		}
		/// Appends a \ref text_gizmo_fragment to the rendered document by calling \ref _append_text().
		text_rendering append(const text_gizmo_fragment &frag) {
			auto font = _renderer->find_font_family(frag.font.family)->get_matching_font(
				frag.font.style, frag.font.weight, frag.font.stretch
			);
			return _append_text(std::u8string_view(frag.contents), *font, frag.font.size, frag.color);
		}

		/// Does nothing. Defined to complete the basic interface.
		void render(ui::renderer_base&, const basic_rendering&) {
		}
		/// Renders the text using the given renderer, at the position specified in the \ref text_rendering.
		/// Additional transformations may be necessary to 
		void render(ui::renderer_base &r, const text_rendering &text) {
			r.draw_plain_text(
				*text.text, vec2d(text.topleft.x, text.topleft.y + text.baseline_correction), text.color
			);
		}
	protected:
		ui::renderer_base *_renderer = nullptr; ///< The renderer.
		const ui::font_family &_font_family; ///< The font family.
		invalid_codepoint_formatter _invalid_cp_fmt; ///< Used to format and display invalid codepoints.
		colord _invalid_cp_color; ///< The color of invalid codepoints.
		double
			_font_size = 0.0, ///< The font size.
			_line_height = 0.0, ///< The height of a line.
			_baseline = 0.0, ///< The desired base line position from the top of the line.
			_tab_width = 0.0, ///< The maximum width of a tab character.
			_line_top = 0.0, ///< The top of the current line.
			_xpos = 0.0; ///< The horizontal position, relative to the left side of the document.

		/// Appends a clip of text to the ending of the document.
		template <typename Char> text_rendering _append_text(
			std::basic_string_view<Char> text, ui::font &font, double size, colord color
		) {
			std::unique_ptr<ui::plain_text> fmttext = _renderer->create_plain_text(
				text, font, size
			);
			vec2d pos = get_position();
			advance_horizontal_position(fmttext->get_width());
			return text_rendering(std::move(fmttext), pos, _baseline - font.get_ascent_em() * size, color);
		}
	};


	/// A standalone component that gathers information about carets to be rendered later.
	struct caret_gatherer {
	public:
		constexpr static std::size_t maximum_num_lookahead_carets = 2; ///< The maximum number of pending carets.

		/// Constructs this struct with the given \ref caret_set, position, \ref fragment_assembler, and a boolean
		/// indicating whether the previous fragment is a stall.
		caret_gatherer(
			const caret_set::container &set, std::size_t pos, const fragment_assembler &ass, bool stall
		) : _carets(set), _assembler(&ass) {
			// find the first candidate caret to render
			auto first = _carets.lower_bound(ui::caret_selection(pos, 0));
			if (first != _carets.begin()) {
				auto prev = first;
				--prev;
				if (prev->first.selection >= pos) {
					first = prev;
				}
			}
			while (first != _carets.end() && _queued.size() < maximum_num_lookahead_carets) {
				std::pair<std::size_t, std::size_t> range = std::minmax(first->first.caret, first->first.selection);
				if (range.second > pos || !_should_end_before_stall(first->first, first->second, stall)) {
					// not too late
					if ( // not too early to start
						range.first < pos ||
						(range.first == pos && _should_start_before_stall(first->first, first->second, stall))
						) { // should jumpstart
						_active.emplace_back(_single_caret_renderer::jumpstart(*_assembler, first));
					} else { // queue for later
						_queued.emplace_back(first);
					}
				}
				++first;
			}
		}

		/// Handles a generated fragment. This function first checks for any carets to be started, then updates all
		/// active renderers.
		template <typename Fragment, typename Rendering> void handle_fragment(
			const Fragment &frag, const Rendering &rend, std::size_t steps, std::size_t posafter
		) {
			// check & start new renderers
			for (auto it = _queued.begin(); it != _queued.end(); ) {
				if (auto && renderer = _single_caret_renderer::start_at_fragment(
					frag, rend, steps, posafter, *this, *it
				)) {
					_active.emplace_back(std::move(renderer.value()));
					// maintain the number of queued carets
					if (caret_set::const_iterator next = _queued.back(); (++next) != _carets.end()) {
						_queued.emplace_back(next);
					}
					it = _queued.erase(it);
				} else {
					++it;
				}
			}
			// update all active renderers
			for (auto it = _active.begin(); it != _active.end(); ) {
				if (!it->handle_fragment(frag, rend, steps, posafter, *this)) { // finished
					it = _active.erase(it);
				} else {
					++it;
				}
			}
		}

		/// Skips the rest of the current line and possibly part of the next line. This function should be called
		/// *before* the metrics in the \ref fragment_assembler are updated.
		void skip_line(bool stall, std::size_t posafter) {
			// first update active renderers
			for (auto it = _active.begin(); it != _active.end(); ) {
				if (!it->handle_line_skip(
					posafter, stall,
					_assembler->get_horizontal_position(), _assembler->get_vertical_position(),
					_assembler->get_vertical_position() + _assembler->get_line_height(),
					*this
				)) {
					it = _active.erase(it);
				} else {
					++it;
				}
			}
			// check & jumpstart or discard pending carets
			for (auto it = _queued.begin(); it != _queued.end(); ) {
				std::pair<std::size_t, std::size_t> range = std::minmax((*it)->first.caret, (*it)->first.selection);
				if ( // too early
					range.first > posafter ||
					(range.first == posafter && !_should_start_before_stall((*it)->first, (*it)->second, stall))
					) {
					++it; // next
				} else { // either start or discard
					if ( // should start
						range.second > posafter ||
						(range.second == posafter && !_should_end_before_stall((*it)->first, (*it)->second, stall))
						) {
						_active.emplace_back(_single_caret_renderer::jumpstart_at_skip_line(*_assembler, *it));
					} // otherwise should only discard
					// queue another & remove entry
					if (caret_set::const_iterator next = _queued.back(); (++next) != _carets.end()) {
						_queued.emplace_back(next);
					}
					it = _queued.erase(it);
				}
			}
		}


		/// Properly stops all active renderers.
		void finish(std::size_t position) {
			for (auto &rend : _active) {
				rend.finish(position, *this);
			}
			// TODO draw the possibly left out "last caret"
		}

		/// Returns a reference to the associated \ref fragment_assembler.
		const fragment_assembler &get_fragment_assembler() const {
			return *_assembler;
		}

		/// Returns the bounding boxes of all carets.
		std::vector<rectd> &get_caret_rects() {
			return _caret_rects;
		}
		/// Returns the layout of all selected regions.
		std::vector<std::vector<rectd>> &get_selection_rects() {
			return _selected_regions;
		}
	protected:
		/// Returns \p true if \p at_stall is \p true and the caret should start before the stall.
		inline static bool _should_start_before_stall(
			ui::caret_selection caret, const caret_data &data, bool at_stall
		) {
			return at_stall && caret.selection > caret.caret && !data.after_stall;
		}
		/// Returns \p true if \p at_stall is \p true and the caret should end before the stall.
		inline static bool _should_end_before_stall(
			ui::caret_selection caret, const caret_data &data, bool at_stall
		) {
			return at_stall && (caret.selection > caret.caret || !data.after_stall);
		}

		/// Handles a single caret. The return values of the \p handle_fragment() methods return \p false if this
		/// caret has ended.
		struct _single_caret_renderer {
		public:
			/// Does nothing when at a \ref no_fragment. Actually, this shouldn't happen.
			inline static std::optional<_single_caret_renderer> start_at_fragment(
				const no_fragment&, const fragment_assembler::basic_rendering&,
				std::size_t, std::size_t, caret_gatherer&, caret_set::const_iterator
			) {
				return std::nullopt;
			}
			/// Tries to start rendering a new caret at the given \ref text_fragment.
			inline static std::optional<_single_caret_renderer> start_at_fragment(
				const text_fragment&, const fragment_assembler::text_rendering &r,
				std::size_t steps, std::size_t posafter, caret_gatherer &rend, caret_set::const_iterator iter
			) {
				_single_caret_renderer res(iter, r.topleft.x);
				if (res._range.second + steps < posafter) { // too late
					return std::nullopt;
				}
				if (res._range.first < posafter) { // start
					rectd caret = r.text->get_character_placement(res._range.first - (posafter - steps));
					res._region_left += caret.xmin;
					if (res._range.first == res._caret->first.caret) { // add caret
						rend._caret_rects.emplace_back(rectd::from_xywh(
							res._region_left, r.topleft.y,
							caret.width(), rend.get_fragment_assembler().get_line_height()
						));
					}
					return res;
				}
				return std::nullopt;
			}
			/// Tries to start rendering a new caret at the given \ref linebreak_fragment.
			inline static std::optional<_single_caret_renderer> start_at_fragment(
				const linebreak_fragment&, const fragment_assembler::basic_rendering &r,
				std::size_t steps, std::size_t posafter, caret_gatherer &rend, caret_set::const_iterator iter
			) {
				return _start_at_solid_fragment(rectd::from_xywh(
					r.topleft.x, r.topleft.y, 10.0, rend.get_fragment_assembler().get_line_height()
				), steps, posafter, rend, iter); // TODO proper width
			}
			/// Tries to start rendering a new caret at the given generic solid fragment.
			template <
				typename Frag, typename Rendering
			> inline static std::optional<_single_caret_renderer> start_at_fragment(
				const Frag&, const Rendering &r, std::size_t steps, std::size_t posafter,
				caret_gatherer &rend, caret_set::const_iterator iter
			) {
				return _start_at_solid_fragment(
					_get_solid_fragment_caret_position(r, rend.get_fragment_assembler()), steps, posafter, rend, iter
				);
			}

			/// Starts rendering a caret halfway at the beginning of the view.
			inline static _single_caret_renderer jumpstart(
				const fragment_assembler &ass, caret_set::const_iterator iter
			) {
				return _single_caret_renderer(iter, ass.get_horizontal_position());
			}

			/// Starts rendering a caret halfway when skipping part of a line.
			inline static _single_caret_renderer jumpstart_at_skip_line(
				const fragment_assembler &ass, caret_set::const_iterator iter
			) {
				vec2d pos = ass.get_position();
				_single_caret_renderer res(iter, pos.x);
				res._append_line_selection(pos.x, pos.y, pos.y + ass.get_line_height());
				return res;
			}

			/// Handles a \ref no_fragment by doing nothing. Normally this should not happen.
			bool handle_fragment(
				const no_fragment&, const fragment_assembler::basic_rendering&,
				std::size_t, std::size_t, caret_gatherer&
			) {
				return true;
			}
			/// Handles a \ref text_fragment.
			bool handle_fragment(
				const text_fragment&, const fragment_assembler::text_rendering &r,
				std::size_t steps, std::size_t posafter, caret_gatherer &rend
			) {
				assert_true_logical(steps > 0, "invalid text fragment");
				if (posafter > _range.second) { // terminate here
					rectd pos = r.text->get_character_placement(_range.second - (posafter - steps));
					_terminate_with_caret(_range.second, rectd::from_xywh(
						pos.xmin + r.topleft.x, rend.get_fragment_assembler().get_vertical_position(),
						pos.width(), rend.get_fragment_assembler().get_line_height()
					), rend);
					return false;
				}
				return true;
			}
			/// Handles a \ref linebreak_fragment.
			bool handle_fragment(
				const linebreak_fragment &frag, const fragment_assembler::basic_rendering &r,
				std::size_t steps, std::size_t posafter, caret_gatherer &rend
			) {
				rectd pos = rectd::from_xywh(
					r.topleft.x, r.topleft.y, 10.0, rend.get_fragment_assembler().get_line_height()
				);
				if (_handle_solid_fragment(pos, steps, posafter, rend)) { // not over, to the next line
					// for soft linebreaks, do not add space after the line
					_append_line_selection(frag.type == ui::line_ending::none ? pos.xmin : pos.xmax, pos.ymin, pos.ymax);
					_region_left = 0.0;
					return true;
				}
				return false;
			}
			/// Handles a generic solid fragment. This includes the \ref image_gizmo_fragment, the
			/// \ref text_gizmo_fragment, the \ref tab_fragment, and the \ref invalid_codepoint_fragment.
			template <typename Frag, typename Rendering> bool handle_fragment(
				const Frag&, const Rendering &r, std::size_t steps, std::size_t posafter, caret_gatherer &rend
			) {
				return _handle_solid_fragment(
					_get_solid_fragment_caret_position(r, rend.get_fragment_assembler()), steps, posafter, rend
				);
			}

			/// Called when the rest of the current line and possibly part of the next line are skipped.
			///
			/// \param posafter The text position after skipping.
			/// \param stall Indicates whether the last skipped fragment is a stall.
			/// \param x The right boundary of the last rendered fragment.
			/// \param ymin The top boundary of the last line.
			/// \param ymax The bottom boundary of the last line.
			/// \param rend The \ref caret_gatherer.
			bool handle_line_skip(
				std::size_t posafter, bool stall, double x, double ymin, double ymax, caret_gatherer &rend
			) {
				if (
					_range.second < posafter || // end before this position
					(_range.second == posafter && _should_end_before_stall(_caret->first, _caret->second, stall))
					) { // stop here
					_terminate(x, ymin, ymax, rend);
					return false;
				} // else jump to the next line
				_append_line_selection(x, ymin, ymax);
				_region_left = 0.0;
				return true;
			}

			/// Properly finishes rendering to this caret. Note that this function may render an extra caret that
			/// should not be visible.
			void finish(std::size_t pos, caret_gatherer &rend) {
				const fragment_assembler &ass = rend.get_fragment_assembler();
				rectd caret = rectd::from_xywh(
					ass.get_horizontal_position(), rend.get_fragment_assembler().get_vertical_position(),
					10.0, ass.get_line_height()
				); // TODO use the width of a space?
				_terminate_with_caret(pos, caret, rend);
			}
		protected:
			caret_set::const_iterator _caret; ///< Iterator to the caret data.
			std::pair<std::size_t, std::size_t> _range; ///< The range of the selection.
			/// The list of rectangles that specify the position of the selected region.
			std::vector<rectd> _selected_regions;
			double _region_left = 0.0; ///< The left boundary of the next selected region.

			/// Initializes this struct given the corresponding caret and the horizontal position.
			explicit _single_caret_renderer(caret_set::const_iterator iter, double x) :
				_caret(iter), _range(std::minmax(_caret->first.caret, _caret->first.selection)), _region_left(x) {
			}

			/// Returns the caret layout for a \ref fragment_assembler::basic_rendering.
			inline static rectd _get_solid_fragment_caret_position(
				const fragment_assembler::basic_rendering &r, const fragment_assembler &ass
			) {
				return rectd(
					r.topleft.x, ass.get_horizontal_position(),
					r.topleft.y, r.topleft.y + ass.get_line_height()
				);
			}
			/// Returns the caret layout for a \ref fragment_assembler::text_rendering.
			inline static rectd _get_solid_fragment_caret_position(
				const fragment_assembler::text_rendering &r, const fragment_assembler &ass
			) {
				return rectd::from_xywh(
					r.topleft.x, r.topleft.y, r.text->get_width(), ass.get_line_height()
				);
			}

			/// Checks if the given caret starts at the given solid fragment (one that's not a text fragment). If so,
			/// returns a corresponding \ref _single_caret_renderer and adds a caret if necessary.
			inline static std::optional<_single_caret_renderer> _start_at_solid_fragment(
				rectd caret, std::size_t steps, std::size_t posafter,
				caret_gatherer &rend, caret_set::const_iterator c
			) {
				_single_caret_renderer res(c, caret.xmin);
				if (res._range.second + steps < posafter) { // too late
					return std::nullopt;
				}
				if (steps == 0) { // stall
					if (res._range.first == posafter && _should_start_before_stall(c->first, c->second, true)) {
						rend._caret_rects.emplace_back(caret);
						return res;
					}
				} else { // not stall
					if (posafter > res._range.first) { // should start
						if (res._caret->first.caret + steps == posafter) { // should also generate caret
							rend._caret_rects.emplace_back(caret);
						}
						return res;
					}
				}
				return std::nullopt;
			}

			/// Handles a fragmen which the caret cannot appear inside.
			bool _handle_solid_fragment(rectd caret, std::size_t steps, std::size_t posafter, caret_gatherer &rend) {
				if (steps == 0) { // stall
					if (posafter == _range.second && _should_end_before_stall(_caret->first, _caret->second, true)) {
						_terminate_with_caret(posafter, caret, rend);
						return false;
					}
				} else { // not stall
					if (posafter > _range.second) { // stop here & this fragment is completely covered
						_terminate_with_caret(posafter - steps, caret, rend);
						return false;
					}
				}
				return true;
			}

			/// Appends to \ref _selected_regions the rectangle corresponding to this line.
			void _append_line_selection(double x, double ymin, double ymax) {
				_selected_regions.emplace_back(_region_left, x, ymin, ymax);
			}

			/// Called right before finishing this caret and selected region. This function appends a caret to
			/// \ref caret_gatherer::_caret_rects if necessary, appends a final selected rectangle to
			/// \ref _selected_regions, then moves it to \ref caret_gatherer::_selected_regions.
			void _terminate_with_caret(std::size_t pos, rectd caret, caret_gatherer &rend) {
				if (_range.second != _caret->first.selection && pos == _range.second) {
					// add caret only if the positions match, and the caret is after the selected region which is
					// nonempty (to avoid rendering the caret twice)
					rend._caret_rects.emplace_back(caret);
				}
				_terminate(caret.xmin, caret.ymin, caret.ymax, rend);
			}
			/// Similar to \ref _terminate_with_caret but does not append a caret region.
			void _terminate(double x, double ymin, double ymax, caret_gatherer &rend) {
				_append_line_selection(x, ymin, ymax);
				rend._selected_regions.emplace_back(std::move(_selected_regions));
			}
		};

		std::vector<rectd> _caret_rects; ///< The positions of all carets.
		std::vector<std::vector<rectd>> _selected_regions; ///< The positions of selected regions.
		const caret_set::container &_carets; ///< The set of carets.
		std::list<_single_caret_renderer> _active; ///< The list of active renderers for individual carets.
		std::list<caret_set::const_iterator> _queued; ///< The list of carets that would start shortly.
		const fragment_assembler *_assembler = nullptr; ///< The associated \ref fragment_assembler.
	};
}
